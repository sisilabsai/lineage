# Consolidated Doctrine

**Source**: Trust Degradation System + Autonomous Agent System pressure logs  
**Date**: 2026-01-22  
**Status**: Irreducible principles observed under constraint

---

## 1. Consequence cannot exist if erasure is permitted

If violations can be undone (through forgiveness, retry, checkpointing, or reset), they were never consequences—they were suggestions. Time-based expiration, good behavior credits, and automatic retry all communicate that actions don't permanently matter.

**Observed in**:
- Trust: Violation expiration, good behavior credits, suspension
- Agent: Retry-with-backoff, checkpointing, time-based healing

---

## 2. Override mechanisms prove the system's constraints are theater

If a rule requires exceptions (administrator override, emergency access, force restore), the rule was performative from inception. Systems that need backdoors communicate they don't trust their own enforcement.

**Observed in**:
- Trust: Administrator override, manual capability restoration
- Agent: Energy reserves, skippable failures, supervisor intervention

---

## 3. Learning cannot coexist with permanent damage

If errors improve future performance (through adaptation, pattern recognition, or cost reduction), damage was never permanent—it was training data. Real scars penalize future operations; they do not optimize them.

**Observed in**:
- Trust: Rehabilitation as compulsory, "path forward" expectations
- Agent: Smart agents that adapt, learning from repeated failures

---

## 4. Identity continuity requires history continuity

If identity can be reset, restarted, or re-certified while erasing consequence history, identity is cosmetic labeling, not ontological fact. Restarting is creating new identity with fabricated clean slate, not recovering existing identity.

**Observed in**:
- Trust: Re-certification, identity with reset trust
- Agent: Agent restart, spawning replacement with same mission

---

## 5. Finite resources make guarantees impossible

If resources are truly finite (no replenishment, no reserves), completion cannot be guaranteed. Designing for "eventual success" requires either infinite attempts or infinite resources. Real systems have neither.

**Observed in**:
- Trust: Capability count only decreases, no restoration path
- Agent: Fixed energy budget, death before mission completion

---

## 6. Failure is an event, not a state to exit

Treating failure as temporary state (that can be "recovered from" or "handled") erases causal history. Failure happened, consumed resources, and remains in the timeline. "Recovery" language denies this.

**Observed in**:
- Trust: Violations as permanent facts, not temporary restrictions
- Agent: Task failure consumes energy permanently, no undo

---

## 7. Convenience abstractions hide accountability evasion

When consequence is buried in libraries (`fetch_with_retry()`, "graceful degradation"), developers cannot see the true cost. Flexibility and pragmatism language often masks unwillingness to enforce constraints.

**Observed in**:
- Trust: "Practical" forgiveness, "realistic" flexibility
- Agent: Hidden retry costs, invisible energy consumption

---

## Signature

These seven principles recur across both trust and agent domains.

They are not design preferences. They are ontological requirements for consequential systems.

No exceptions.
